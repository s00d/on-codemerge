import { type LanguageDefinition, TokenType } from '../../../types';

export const rubyDefinition: LanguageDefinition = {
  name: 'ruby',
  patterns: {
    [TokenType.Comment]: /^#.*$/,
    [TokenType.String]:
      /^(%[qQrwWx]?\{(?:[^}\\]|\\.)*\}|%[qQrwWx]?\[(?:[^\]\\]|\\.)*\]|%[qQrwWx]?\((?:[^)\\]|\\.)*\)|%[qQrwWx]?<(?:[^>\\]|\\.)*>|(['"])(?:\\[\s\S]|(?!\1)[^\\])*\1)/,
    [TokenType.Number]: /^\b(?:0[xX][0-9a-fA-F]+|\d+(?:\.\d+)?(?:[eE][+-]?\d+)?)\b/,
    [TokenType.Function]: /^\b[a-zA-Z_]\w*[?!]?(?=\s*[({])/,
    [TokenType.Symbol]: /^:[a-zA-Z_]\w*/,
    [TokenType.Variable]: /^(?:@{1,2}|\$)[a-zA-Z_]\w*/,
    [TokenType.Operator]:
      /^(?:<<|>>|<=|>=|<=>|={3}|!={2}|={2}|=~|!~|&&|\|\||\.{2,3}|[+\-*/%&|^<>!~]=?)/,
    [TokenType.Punctuation]: /^[{}[\]().,;]/,
  },
  keywords: [
    'alias',
    'and',
    'begin',
    'break',
    'case',
    'class',
    'def',
    'defined?',
    'do',
    'else',
    'elsif',
    'end',
    'ensure',
    'false',
    'for',
    'if',
    'in',
    'module',
    'next',
    'nil',
    'not',
    'or',
    'redo',
    'rescue',
    'retry',
    'return',
    'self',
    'super',
    'then',
    'true',
    'undef',
    'unless',
    'until',
    'when',
    'while',
    'yield',
  ],
};
